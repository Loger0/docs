<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>准备工作 | Roger</title>
    <meta name="generator" content="VuePress 1.9.9">
    <link rel="icon" href="/docs/assets/img/bitbug_favicon.ico">
    <meta name="description" content="">
    
    <link rel="preload" href="/docs/assets/css/0.styles.16d44142.css" as="style"><link rel="preload" href="/docs/assets/js/app.055589eb.js" as="script"><link rel="preload" href="/docs/assets/js/2.a4ce278c.js" as="script"><link rel="preload" href="/docs/assets/js/12.261b571c.js" as="script"><link rel="prefetch" href="/docs/assets/js/10.cbcd239a.js"><link rel="prefetch" href="/docs/assets/js/11.9a4deab0.js"><link rel="prefetch" href="/docs/assets/js/13.c2afaf3a.js"><link rel="prefetch" href="/docs/assets/js/14.8cf83f01.js"><link rel="prefetch" href="/docs/assets/js/15.e79263b3.js"><link rel="prefetch" href="/docs/assets/js/16.b653720c.js"><link rel="prefetch" href="/docs/assets/js/17.ce002f15.js"><link rel="prefetch" href="/docs/assets/js/18.3a891816.js"><link rel="prefetch" href="/docs/assets/js/19.a1608cdb.js"><link rel="prefetch" href="/docs/assets/js/20.f6f64be1.js"><link rel="prefetch" href="/docs/assets/js/21.b1da476d.js"><link rel="prefetch" href="/docs/assets/js/22.3a6b08d9.js"><link rel="prefetch" href="/docs/assets/js/23.79dbccdc.js"><link rel="prefetch" href="/docs/assets/js/24.af45a295.js"><link rel="prefetch" href="/docs/assets/js/25.a6b4d454.js"><link rel="prefetch" href="/docs/assets/js/3.da040ca8.js"><link rel="prefetch" href="/docs/assets/js/4.c639701e.js"><link rel="prefetch" href="/docs/assets/js/5.5b10c8b6.js"><link rel="prefetch" href="/docs/assets/js/6.eb4985eb.js"><link rel="prefetch" href="/docs/assets/js/7.962eaaf6.js"><link rel="prefetch" href="/docs/assets/js/8.a2430b0b.js"><link rel="prefetch" href="/docs/assets/js/9.e51a277c.js">
    <link rel="stylesheet" href="/docs/assets/css/0.styles.16d44142.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/docs/" class="home-link router-link-active"><!----> <span class="site-name">Roger</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/docs/" class="nav-link">
    首页
  </a></div><div class="nav-item"><a href="https://juejin.cn/user/1913628905977070" target="_blank" rel="noopener noreferrer" class="nav-link external">
    掘金
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div><div class="nav-item"><a href="/docs/Native/Promise/" aria-current="page" class="nav-link router-link-exact-active router-link-active">
    前端杂谈
  </a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="技术分类" class="dropdown-title"><span class="title">技术分类</span> <span class="arrow down"></span></button> <button type="button" aria-label="技术分类" class="mobile-dropdown-title"><span class="title">技术分类</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/docs/interview/html/" class="nav-link">
    html
  </a></li><li class="dropdown-item"><!----> <a href="/docs/interview/css/" class="nav-link">
    css
  </a></li><li class="dropdown-item"><!----> <a href="/docs/interview/js/" class="nav-link">
    JS
  </a></li><li class="dropdown-item"><!----> <a href="/docs/interview/node/" class="nav-link">
    Node
  </a></li><li class="dropdown-item"><!----> <a href="/docs/Vue/" class="nav-link">
    Vue
  </a></li><li class="dropdown-item"><!----> <a href="/docs/Chrome/" class="nav-link">
    浏览器
  </a></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/docs/" class="nav-link">
    首页
  </a></div><div class="nav-item"><a href="https://juejin.cn/user/1913628905977070" target="_blank" rel="noopener noreferrer" class="nav-link external">
    掘金
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div><div class="nav-item"><a href="/docs/Native/Promise/" aria-current="page" class="nav-link router-link-exact-active router-link-active">
    前端杂谈
  </a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="技术分类" class="dropdown-title"><span class="title">技术分类</span> <span class="arrow down"></span></button> <button type="button" aria-label="技术分类" class="mobile-dropdown-title"><span class="title">技术分类</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/docs/interview/html/" class="nav-link">
    html
  </a></li><li class="dropdown-item"><!----> <a href="/docs/interview/css/" class="nav-link">
    css
  </a></li><li class="dropdown-item"><!----> <a href="/docs/interview/js/" class="nav-link">
    JS
  </a></li><li class="dropdown-item"><!----> <a href="/docs/interview/node/" class="nav-link">
    Node
  </a></li><li class="dropdown-item"><!----> <a href="/docs/Vue/" class="nav-link">
    Vue
  </a></li><li class="dropdown-item"><!----> <a href="/docs/Chrome/" class="nav-link">
    浏览器
  </a></li></ul></div></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>Promise</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/docs/Native/Promise/" aria-current="page" class="active sidebar-link">手写原生Promise</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/docs/Native/Promise/#准备工作" class="sidebar-link">准备工作</a></li><li class="sidebar-sub-header"><a href="/docs/Native/Promise/#创建promise类" class="sidebar-link">创建Promise类</a></li><li class="sidebar-sub-header"><a href="/docs/Native/Promise/#调用执行器函数" class="sidebar-link">调用执行器函数</a></li><li class="sidebar-sub-header"><a href="/docs/Native/Promise/#向执行器传入两个参数" class="sidebar-link">向执行器传入两个参数</a></li><li class="sidebar-sub-header"><a href="/docs/Native/Promise/#改变状态" class="sidebar-link">改变状态</a></li><li class="sidebar-sub-header"><a href="/docs/Native/Promise/#添加上捕获执行器的报错" class="sidebar-link">添加上捕获执行器的报错</a></li><li class="sidebar-sub-header"><a href="/docs/Native/Promise/#编写then方法" class="sidebar-link">编写then方法</a></li><li class="sidebar-sub-header"><a href="/docs/Native/Promise/#解决异步修改状态时-then方法的bug" class="sidebar-link">解决异步修改状态时 then方法的bug</a></li><li class="sidebar-sub-header"><a href="/docs/Native/Promise/#处理then方法的返回值" class="sidebar-link">处理then方法的返回值</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/docs/Native/Promise/#第一种情况-then方法的参数不为函数时" class="sidebar-link">第一种情况：then方法的参数不为函数时</a></li><li class="sidebar-sub-header"><a href="/docs/Native/Promise/#第二种情况-当回调函数执行有报错" class="sidebar-link">第二种情况：当回调函数执行有报错</a></li><li class="sidebar-sub-header"><a href="/docs/Native/Promise/#第三种情况-当回调函数的返回值为-promise-时" class="sidebar-link">第三种情况：当回调函数的返回值为 Promise 时</a></li></ul></li><li class="sidebar-sub-header"><a href="/docs/Native/Promise/#添加到微任务" class="sidebar-link">添加到微任务</a></li><li class="sidebar-sub-header"><a href="/docs/Native/Promise/#实现catch方法" class="sidebar-link">实现catch方法</a></li><li class="sidebar-sub-header"><a href="/docs/Native/Promise/#实现静态resolve方法" class="sidebar-link">实现静态resolve方法</a></li><li class="sidebar-sub-header"><a href="/docs/Native/Promise/#实现静态reject方法" class="sidebar-link">实现静态reject方法</a></li></ul></li><li><a href="/docs/Native/PromiseInterView/" class="sidebar-link">手撕Promise面试题</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Axios</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h2 id="准备工作"><a href="#准备工作" class="header-anchor">#</a> 准备工作</h2> <ol><li>我使用的是class类来实现Promise的构造函数，如果不会class可以学习一下他的语法</li> <li>了解原生Primise的特性，需要学会使用Promise才可以通过他的功能来思考是如何实现的</li> <li>我们创建的类名叫做myPromise,我会用原生Promise去举例子，大家不要看错了</li></ol> <h2 id="创建promise类"><a href="#创建promise类" class="header-anchor">#</a> 创建Promise类</h2> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">myPromise</span><span class="token punctuation">{</span>
    <span class="token function">construtor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="调用执行器函数"><a href="#调用执行器函数" class="header-anchor">#</a> 调用执行器函数</h2> <p>执行器函数就是我我们每次new Promise时传入的参数，他是一个同步执行的函数，在每次new时就会执行</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 原生Promise</span>
<span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">myPromise</span><span class="token punctuation">{</span>
    <span class="token function">construtor</span><span class="token punctuation">(</span><span class="token parameter">executor</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token comment">// （executor 是一个同步函数） 我们每次new Promise时就会执行</span>
        <span class="token function">executor</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="向执行器传入两个参数"><a href="#向执行器传入两个参数" class="header-anchor">#</a> 向执行器传入两个参数</h2> <p>通常我们在使用<code>Promise</code>的时候，首先 new Promise() 并且传入一个函数，函数接收两个参数 <code>resolve</code> 成功时调用的函数 <code>reject</code> 失败时执行的函数</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 原生promise</span>
<span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span>reject</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token comment">// 成功时</span>
    <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token string">'成功'</span><span class="token punctuation">)</span>
    <span class="token comment">//失败时</span>
    <span class="token function">reject</span><span class="token punctuation">(</span><span class="token string">'失败'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p>通过原生Promise的代码，我们可以传入两个函数 <code>resolve</code> 代表成功 <code>reject</code> 代表失败</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">myPromise</span><span class="token punctuation">{</span>
      <span class="token comment">// executor 执行器  执行 new Promise((resolve,reject)</span>
      <span class="token comment">// =&gt; {函数体}) 中传入的函数 (resolve,reject) =&gt; {函数体}</span>
    <span class="token function">construtor</span><span class="token punctuation">(</span><span class="token parameter">executor</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token comment">// 我们需要定义这两个函数</span>
        <span class="token comment">// 成功执行的函数</span>
        <span class="token keyword">const</span> <span class="token function-variable function">resolve</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
        <span class="token comment">// 失败执行的函数</span>
        <span class="token keyword">const</span> <span class="token function-variable function">reject</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">reason</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
        <span class="token comment">// （executor 是一个同步函数） 我们每次new Promise时就会执行</span>
        <span class="token function">executor</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span>reject<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>两个方法都需要使用箭头函数，否则this会指向window则无法调用实例方法,如果非要用function定义可以使用bind更改this指向<code>executor(resolve,reject)</code>更改为<code>executor(resolve.bind(this),reject.bind(this))</code></p> <h2 id="改变状态"><a href="#改变状态" class="header-anchor">#</a> 改变状态</h2> <p>当我们调用了<code>resolve</code>或者<code>reject</code>函数时状态会改变,并且状态是不可逆的，只有<code>pending</code>变成<code>fulfilled</code>和<code>pending</code>变成<code>rejected</code></p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 原生promise</span>
<span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span>reject</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token comment">// 当我们调用resolve函数时 Promise内部会把状态修改为 fulfilled reject同理</span>
    <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token string">'成功'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p>我们就需要添加上修改状态的代码,并且保存调用传入的结果</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 定义状态常量 易于后期维护</span>
<span class="token keyword">const</span> <span class="token constant">PENDING</span> <span class="token operator">=</span> <span class="token string">&quot;pending&quot;</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token constant">FULFILLED</span> <span class="token operator">=</span> <span class="token string">&quot;fulfilled&quot;</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token constant">REJECTED</span> <span class="token operator">=</span> <span class="token string">&quot;rejected&quot;</span><span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">myPromise</span> <span class="token punctuation">{</span>
   <span class="token comment">// 也可以定义在类里面</span>
   <span class="token comment">// static PENDING = &quot;pending&quot;;</span>
   <span class="token comment">// static FULFILLED = &quot;fulfilled&quot;;</span>
   <span class="token comment">// static REJECTED = &quot;rejected&quot;;</span>
  <span class="token comment">// 返回的结果</span>
  #result <span class="token operator">=</span> <span class="token keyword">undefined</span><span class="token punctuation">;</span>
  <span class="token comment">// 当前 Primise 的状态 默认为 pending</span>
  #state <span class="token operator">=</span> <span class="token constant">PENDING</span><span class="token punctuation">;</span>

  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">executor</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 执行器中传入两个函数</span>

    <span class="token comment">// 成功的函数</span>
    <span class="token keyword">const</span> <span class="token function-variable function">resolve</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">#changeState</span><span class="token punctuation">(</span><span class="token constant">FULFILLED</span><span class="token punctuation">,</span> data<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>

    <span class="token comment">// 失败的函数</span>
    <span class="token keyword">const</span> <span class="token function-variable function">reject</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">reason</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">#changeState</span><span class="token punctuation">(</span><span class="token constant">REJECTED</span><span class="token punctuation">,</span> reason<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>

      <span class="token function">executor</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// 抽离出修改状态的函数 state 代表要修改的状态 (fulfilled/rejected) result 代表结果</span>
  <span class="token comment">// 修改Promise状态，并且把结果传递过去</span>
  <span class="token function">#changeState</span><span class="token punctuation">(</span><span class="token parameter">state<span class="token punctuation">,</span> result</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// Promise的特性 状态不可逆 只有状态为 pending 时才可以修改 状态</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>#state <span class="token operator">!==</span> <span class="token constant">PENDING</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token comment">// 修改我们当前的状态</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>#state <span class="token operator">=</span> state<span class="token punctuation">;</span>
    <span class="token comment">// 保存传入的结果</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>#result <span class="token operator">=</span> result<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="添加上捕获执行器的报错"><a href="#添加上捕获执行器的报错" class="header-anchor">#</a> 添加上捕获执行器的报错</h2> <p>如果我们在传入的函数发生报错时原生Promise是怎么处理的</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">throw</span> <span class="token string">'err'</span>  <span class="token comment">// 原生Promise在捕获到异常时会调用rejected函数并且把error信息当作参数传入</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p>我们只需要通过try catch即可实现这个效果</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 在我们的执行器中添加上 try catch</span>
<span class="token keyword">try</span><span class="token punctuation">{</span>
   <span class="token function">executor</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token keyword">catch</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">{</span>
   <span class="token comment">// 调用reject方法并传入错误信息</span>
   <span class="token function">reject</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><blockquote><p>这个时候要注意 try catch 并不能捕获到 异步执行的函数抛出的错误 原生Promise也并没有实现</p></blockquote> <h2 id="编写then方法"><a href="#编写then方法" class="header-anchor">#</a> 编写then方法</h2> <p>then方法是Promise中的关键</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 原生promise</span>
<span class="token keyword">let</span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span>reject</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token string">'成功'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

p<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>
    <span class="token comment">// 状态成功时的函数</span>
    <span class="token parameter">res</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span>
    <span class="token comment">// 状态为失败时的函数</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token parameter">err</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">)</span>
</code></pre></div><div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">/*
  then方法两个参数就是我们调用时传入的两个
  .then(res =&gt; {},err =&gt; {})
*/</span>
<span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">onFulfilled<span class="token punctuation">,</span> onRejected</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// return 一个Promise实例就是链式调用的关键</span>
  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">myPromise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token comment">// 当状态为成功时执行的函数</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>#state <span class="token operator">===</span> <span class="token constant">FULFILLED</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> onFulfilled <span class="token operator">===</span> <span class="token string">'function'</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token comment">// 调用成功的回调并把结果传入</span>
            <span class="token function">onFulfilled</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>#result<span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>#state <span class="token operator">===</span> <span class="token constant">REJECTED</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> onRejected <span class="token operator">===</span> <span class="token string">'function'</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token comment">// 调用失败的回调并把结果传入</span>
            <span class="token function">onRejected</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>#result<span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="解决异步修改状态时-then方法的bug"><a href="#解决异步修改状态时-then方法的bug" class="header-anchor">#</a> 解决异步修改状态时 then方法的bug</h2> <blockquote><p>当我们执行器中使用了异步函数调用resolve或者reject时，我们在调用then方式时，状态为pending是得不到值的,我们需要把then方法中的函数保存到一个数组中，接下来用代码演示</p></blockquote> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span>reject</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token comment">// 在1秒后再执行修改状态</span>
    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token string">'成功'</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p>我们只需要定义一个数组把then方法的参数储存起来即可，在适当的时候取出执行，那么我们在那里执行呢，我们之前定义了一个 <code>#changeState</code> 方法，专门修改状态的函数，那么当状态修改时我们再从数组中取出函数执行不就可以了</p> <ol><li>定义一个数组 <code>#handles</code></li> <li>每次调用<code>then</code>方法把参数<code>push</code>到数组中</li> <li>定义一个<code>#run</code>方法 用来执行 <code>#handle</code> 中的方法</li> <li>每次修改状态都会触发<code>#changeState</code>方法，在<code>#changeState</code>方法中调用<code>#run</code>方法即可</li></ol> <p>第一步：定义空数组</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 返回的结果</span>
#result <span class="token operator">=</span> <span class="token keyword">undefined</span><span class="token punctuation">;</span>
<span class="token comment">// 当前 Primise 的状态 默认为 pending</span>
#state <span class="token operator">=</span> <span class="token constant">PENDING</span><span class="token punctuation">;</span>
<span class="token comment">// 储存then方法中的参数 首先定义一个数组用于储存</span>
#handles <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
</code></pre></div><p>第二步：添加then方法</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">/*
    then方法两个参数就是我们调用时传入的两个
    .then(res =&gt; {},err =&gt; {})
*/</span>
<span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">onFulfilled<span class="token punctuation">,</span> onRejected</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// return 一个Promise实例就是链式调用的关键</span>
  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">myPromise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token comment">// 把属性push到一个数组中是因为</span>
    <span class="token comment">// 当遇到异步函数是，调用then方法，这是promise的状态为pending</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>#handles<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
      onFulfilled<span class="token punctuation">,</span>
      onRejected<span class="token punctuation">,</span>
      resolve<span class="token punctuation">,</span>
      reject<span class="token punctuation">,</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">#run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>第三步：添加#run方法</p> <blockquote><p>当每次调用run方法时，如果状态为pending则不执行，当状态发生了修改时，通过数组shift方法，提取数组第一个元素，当状态为成功时调用<code>onFulfilled</code>当状态为失败时调用<code>onRejected</code></p></blockquote> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 执行储存器内的方法</span>
<span class="token function">#run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 当状态为pending时不执行</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>#state <span class="token operator">===</span> <span class="token constant">PENDING</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>
  <span class="token comment">// 当储存器中没有数据时不执行</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>#handles<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 解构出所有的属性</span>
    <span class="token keyword">const</span> <span class="token punctuation">{</span> onFulfilled<span class="token punctuation">,</span> onRejected<span class="token punctuation">,</span> resolve<span class="token punctuation">,</span> reject <span class="token punctuation">}</span> <span class="token operator">=</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>#handles<span class="token punctuation">.</span><span class="token function">shift</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 当状态为成功时</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>#state <span class="token operator">===</span> <span class="token constant">FULFILLED</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 判断是否为函数 可能是null 或者其他属性</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> onFulfilled <span class="token operator">===</span> <span class="token string">&quot;function&quot;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">onFulfilled</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>#result<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 当状态为失败时</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>#state <span class="token operator">===</span> <span class="token constant">REJECTED</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 判断是否为函数 可能是null 或者其他属性</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> onRejected <span class="token operator">===</span> <span class="token string">&quot;function&quot;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">onRejected</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>#result<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>第四步： 在#changeState中调用#run方法</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">#changeState</span><span class="token punctuation">(</span><span class="token parameter">state<span class="token punctuation">,</span> result</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
 <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>#state <span class="token operator">!==</span> <span class="token constant">PENDING</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>
 <span class="token keyword">this</span><span class="token punctuation">.</span>#state <span class="token operator">=</span> state<span class="token punctuation">;</span>
 <span class="token keyword">this</span><span class="token punctuation">.</span>#result <span class="token operator">=</span> result<span class="token punctuation">;</span>
 <span class="token comment">// 在最后执行#run即可</span>
 <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">#run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p><strong>大家可以通过 new一个我们自己创建的实例 测试执行异步代码时是否可以获得值</strong></p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">myPromise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span>reject</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
     <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token string">'成功'</span><span class="token punctuation">)</span>
     <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
p<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">res</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token comment">// 如果获取到值证明成功</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

</code></pre></div><h2 id="处理then方法的返回值"><a href="#处理then方法的返回值" class="header-anchor">#</a> 处理then方法的返回值</h2> <p>then方法的返回值会有3种情况</p> <h3 id="第一种情况-then方法的参数不为函数时"><a href="#第一种情况-then方法的参数不为函数时" class="header-anchor">#</a> 第一种情况：then方法的参数不为函数时</h3> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span>reject</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token string">'成功'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

p<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 没有传递回调函数</span>
</code></pre></div><p>Promise有一个特性就是穿透效果，当你调用了then方法但是没有传参，那么promise内部会调用当前promise的resolve方法并且把当前promise的结果传递进去，返回的就是一个成功状态的promise，下一次调用then方法依然可以获得值</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">#run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>#state <span class="token operator">===</span> <span class="token constant">PENDING</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>#handles<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> <span class="token punctuation">{</span> onFulfilled<span class="token punctuation">,</span> onRejected<span class="token punctuation">,</span> resolve<span class="token punctuation">,</span> reject <span class="token punctuation">}</span> <span class="token operator">=</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>#handles<span class="token punctuation">.</span><span class="token function">shift</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 当状态为成功时</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>#state <span class="token operator">===</span> <span class="token constant">FULFILLED</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 判断是否为函数 可能是null 或者其他属性</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> onFulfilled <span class="token operator">===</span> <span class="token string">&quot;function&quot;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token function">onFulfilled</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>#result<span class="token punctuation">)</span><span class="token punctuation">;</span> 
      <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>
        <span class="token comment">// 当 onFulfilled 不是一个函数时 调用 resolve 方法</span>
        <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>#result<span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 当状态为失败时</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>#state <span class="token operator">===</span> <span class="token constant">REJECTED</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 判断是否为函数 可能是null 或者其他属性</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> onRejected <span class="token operator">===</span> <span class="token string">&quot;function&quot;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token function">onRejected</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>#result<span class="token punctuation">)</span><span class="token punctuation">;</span> 
      <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>
          <span class="token function">reject</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>#result<span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这里可能大家会有疑惑，当then方法的参数不为函数时，什么时候调用 resolve 什么时候调用 reject 呢，可以通过原生Promise得出结论</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span>reject</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token string">'成功'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">res</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token comment">// 当调用了resolve方法 当前 Promise 的状态为 fulfilled 当然执行的是 onFulfilled</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">catch</span><span class="token punctuation">(</span><span class="token parameter">err</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token comment">// 这里打印的结果是 成功</span>
</code></pre></div><p>那如果一开始Promise的状态为 rejected 呢，后面的then方法还会执行吗</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span>reject</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token function">reject</span><span class="token punctuation">(</span><span class="token string">'失败'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token function">catch</span><span class="token punctuation">(</span><span class="token parameter">err</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token comment">// 无论你在这里调用了多少个 then 方法都不会执行的 因为只要状态为 reject 时就会跑到 catch 方法中</span>
</code></pre></div><p>我们可以得出结论,什么时候该调用 resolve 方法呢,当前状态为 fulfilled 时调用 resolve 方法，当前状态为 rejected 时调用 reject 方法，传递到后面的链式调用中</p> <h3 id="第二种情况-当回调函数执行有报错"><a href="#第二种情况-当回调函数执行有报错" class="header-anchor">#</a> 第二种情况：当回调函数执行有报错</h3> <p>使用 try catch 捕获调用函数时的报错，在我们的 #run 方法中添加 try catch 即可，当我们的回调函数执行没有错误时就调用 resolve 方法，有错误则调用 reject 方法，我这里展示部分代码</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 当状态为成功时</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>#state <span class="token operator">===</span> <span class="token constant">FULFILLED</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 判断是否为函数 可能是null 或者其他属性</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> onFulfilled <span class="token operator">===</span> <span class="token string">&quot;function&quot;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">try</span><span class="token punctuation">{</span>
          <span class="token keyword">const</span> data <span class="token operator">=</span> <span class="token function">onFulfilled</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>#result<span class="token punctuation">)</span><span class="token punctuation">;</span>   
          <span class="token function">resolve</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span>
      <span class="token punctuation">}</span><span class="token keyword">catch</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">{</span>
          <span class="token function">reject</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>#result<span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>
    <span class="token comment">// 当 onFulfilled 不是一个函数时 调用 resolve 方法</span>
    <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>#result<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">// 当状态为失败时</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>#state <span class="token operator">===</span> <span class="token constant">REJECTED</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 判断是否为函数 可能是null 或者其他属性</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> onRejected <span class="token operator">===</span> <span class="token string">&quot;function&quot;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">try</span><span class="token punctuation">{</span>
          <span class="token keyword">const</span> data <span class="token operator">=</span> <span class="token function">onRejected</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>#result<span class="token punctuation">)</span><span class="token punctuation">;</span>
          <span class="token function">resolve</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span>
      <span class="token punctuation">}</span><span class="token keyword">catch</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">{</span>
          <span class="token function">reject</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>#result<span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>
      <span class="token function">reject</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>#result<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这边的重复代码比较多，我们可以进行一个抽取，定义一个 #runOne 方法</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 接收一个回调函数 callback 还有 成功/失败时需要调用的函数 resolve reject</span>
<span class="token function">#runOne</span><span class="token punctuation">(</span><span class="token parameter">callback<span class="token punctuation">,</span>resolve<span class="token punctuation">,</span>reject</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token comment">// 首先要判断当回调函数不为函数时</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> callback <span class="token operator">!==</span> <span class="token string">'function'</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token comment">// 判断当前状态决定调用 resolve 还是 reject</span>
        <span class="token keyword">const</span> settled <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>#state <span class="token operator">===</span> <span class="token constant">FULFILLED</span> <span class="token operator">?</span> resolve <span class="token operator">:</span> reject
        <span class="token comment">// 调用方法传递参数</span>
        <span class="token function">settled</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>#result<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    
    <span class="token comment">// 下面使用 try catch 捕获函数可能发生的错误</span>
    <span class="token keyword">try</span><span class="token punctuation">{</span>
       <span class="token comment">// 没有报错则调用resolve方法把函数的返回值添加到返回的Promise的结果</span>
       <span class="token keyword">const</span> data <span class="token operator">=</span> <span class="token function">callback</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>#result<span class="token punctuation">)</span>
       <span class="token function">resolve</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token keyword">catch</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">{</span>
       <span class="token comment">// 如果有报错则调用 reject 方法把错误信息传递进去</span>
       <span class="token function">reject</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre></div><p>我们原来的函数调用这个函数就可以了</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>#state <span class="token operator">===</span> <span class="token constant">FULFILLED</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">#runOne</span><span class="token punctuation">(</span>onFulfilled<span class="token punctuation">,</span>resolve<span class="token punctuation">,</span>reject<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token comment">// 当状态为失败时</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>#state <span class="token operator">===</span> <span class="token constant">REJECTED</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">#runOne</span><span class="token punctuation">(</span>onRejected<span class="token punctuation">,</span> resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="第三种情况-当回调函数的返回值为-promise-时"><a href="#第三种情况-当回调函数的返回值为-promise-时" class="header-anchor">#</a> 第三种情况：当回调函数的返回值为 Promise 时</h3> <p>首先我们需要定义一个函数，专门判断当前返回值是不是 promise，判断是否为promise正确来说是判断是否符合promise的A+规范，判断条件是，当我们的返回值是一个对象或者函数，并且有then方法，就是符合条件的</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 判断是否为Promise</span>
<span class="token function">#isPromiseLike</span><span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 当你的返回值为构造函数或者是对象</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>data <span class="token operator">!==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> <span class="token keyword">typeof</span> data <span class="token operator">===</span> <span class="token string">&quot;object&quot;</span><span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token keyword">typeof</span> data <span class="token operator">===</span> <span class="token string">&quot;function&quot;</span> <span class="token punctuation">{</span>
    <span class="token comment">// 并且有一个then方法 就满足了 A+ 规范</span>
    <span class="token keyword">return</span> <span class="token keyword">typeof</span> data<span class="token punctuation">.</span>then <span class="token operator">===</span> <span class="token string">&quot;function&quot;</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><div class="language-js extra-class"><pre class="language-js"><code><span class="token function">#runOne</span><span class="token punctuation">(</span><span class="token parameter">callback<span class="token punctuation">,</span> resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> callback <span class="token operator">!==</span> <span class="token string">&quot;function&quot;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">const</span> settled <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>#state <span class="token operator">===</span> <span class="token constant">FULFILLED</span> <span class="token operator">?</span> resolve <span class="token operator">:</span> reject<span class="token punctuation">;</span>
      <span class="token function">settled</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>#result<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
      <span class="token keyword">const</span> data <span class="token operator">=</span> <span class="token function">callback</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>#result<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token comment">// 第三种情况 返回值为 Promise 时</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">#isPromiseLike</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// promise成功则调用 resolve 方法 失败调用 reject 方法</span>
        data<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token comment">// 不是 promise 则直接添加到 resolve</span>
        <span class="token function">resolve</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>err<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 当 then 方法内报错时 我们手动添加到 reject 方法中</span>
      <span class="token function">reject</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="添加到微任务"><a href="#添加到微任务" class="header-anchor">#</a> 添加到微任务</h2> <p>Promise是一个异步任务，并且是微任务，我们需要把then方法的回调函数添加到微任务中，首先我们定义一个添加到微任务的函数</p> <p><strong>我们需要判断代码的运行环境，对应不同的方法添加到微队列</strong></p> <p>我们定义一个名为 #runMicroTask 的函数传入一个函数</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">#runMicroTask</span><span class="token punctuation">(</span><span class="token parameter">func</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 这里是判断当前是否为node环境</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> process <span class="token operator">===</span> <span class="token string">&quot;object&quot;</span> <span class="token operator">&amp;&amp;</span> <span class="token keyword">typeof</span> process<span class="token punctuation">.</span>nextTick <span class="token operator">===</span> <span class="token string">&quot;function&quot;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    process<span class="token punctuation">.</span><span class="token function">nextTick</span><span class="token punctuation">(</span>func<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 这里是判断浏览器环境</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> MutationObserver <span class="token operator">===</span> <span class="token string">&quot;function&quot;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> ob <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MutationObserver</span><span class="token punctuation">(</span>func<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">const</span> textNode <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createTextNode</span><span class="token punctuation">(</span><span class="token string">&quot;1&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    ob<span class="token punctuation">.</span><span class="token function">observe</span><span class="token punctuation">(</span>textNode<span class="token punctuation">,</span> <span class="token punctuation">{</span>
      <span class="token literal-property property">characterData</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    textNode<span class="token punctuation">.</span>data <span class="token operator">=</span> <span class="token string">&quot;2&quot;</span><span class="token punctuation">;</span>
    <span class="token comment">// 当没有api时，只能调用定时器了</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token function">setTimeout</span><span class="token punctuation">(</span>func<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>Vue中的$nextTick()使用的也是MutationObserver这个api实现微任务，<a href="https://juejin.cn/post/7026744896820084766" target="_blank" rel="noopener noreferrer">可以看看这篇文章帮助理解<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p><strong>最后我们把回调函数的执行全部放在这个函数当中</strong></p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">#runOne</span><span class="token punctuation">(</span><span class="token parameter">callback<span class="token punctuation">,</span> resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">#runMicroTask</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        <span class="token operator">...</span><span class="token operator">...</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">)</span><span class="token punctuation">}</span>
</code></pre></div><blockquote><p>上面的代码实现的是Promise的A+规范，下面的代码是es6新增的方法，便于我们开发</p></blockquote> <h2 id="实现catch方法"><a href="#实现catch方法" class="header-anchor">#</a> 实现catch方法</h2> <p>catch方法的实现很简单，他代替的是then方法的第二个参数，所以我们直接调用then方法，把第二个参数传递进去即可</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">catch</span><span class="token punctuation">(</span>onRejected<span class="token punctuation">)</span><span class="token punctuation">{</span>
   <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> onRejected<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="实现静态resolve方法"><a href="#实现静态resolve方法" class="header-anchor">#</a> 实现静态resolve方法</h2> <p>官网描述的非常清晰，我们就是根据官网的描述去写代码<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise#%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95" target="_blank" rel="noopener noreferrer">MDN官网对Promise静态方法的描述<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p>官方描述：
返回一个状态由给定 value 决定的 <code>Promise</code> 对象。如果该值是 thenable（即，带有 <code>then</code> 方法的对象），返回的 Promise 对象的最终状态由 then 方法执行结果决定；否则，返回的 Promise 对象状态为已兑现，并且将该 value 传递给对应的 then 方法</p> <ol><li><strong>当resolve方法传入的参数为我们自己写的myPromise</strong></li></ol> <p>官方描述的意思就是当我们传入一个promise对象时，我们直接返回这个promise即可</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span>reject</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span> <span class="token operator">===</span> p <span class="token comment">// true</span>
</code></pre></div><ol start="2"><li><strong>当resolve方法传入的参数满足了A+规范时</strong></li></ol> <p>官方描述的意思是，当满足A+规范时，就调用他的then方法</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span>reject</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><ol start="3"><li><strong>当不满足以上情况则直接返回把值传入一个promise对象返回即可</strong></li></ol> <div class="language-js extra-class"><pre class="language-js"><code>Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token number">123</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">res</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span> <span class="token comment">// 123</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p><em>根据以上描述来书写我们的resolve方法</em></p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">static</span> <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token parameter">value</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 首先判断参数是否是我们myPromise的实例对象，如果是则直接返回</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>value <span class="token keyword">instanceof</span> <span class="token class-name">myPromise</span><span class="token punctuation">)</span> <span class="token keyword">return</span> value<span class="token punctuation">;</span>
  <span class="token keyword">let</span> _resolve<span class="token punctuation">,</span> _reject<span class="token punctuation">;</span>
  <span class="token comment">// 因为静态方法中是无法调用this的，所以我们需要借助实例对象来调用实例方法</span>
  <span class="token comment">// 创建一个promise供后期返回</span>
  <span class="token keyword">const</span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">myPromise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    _reject <span class="token operator">=</span> reject<span class="token punctuation">;</span>
    _resolve <span class="token operator">=</span> resolve<span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// 当参数满足了A+规范时，调用他的then方法即可</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token punctuation">.</span><span class="token function">#isPromiseLike</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    value<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>_resolve<span class="token punctuation">,</span> _reject<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
  <span class="token comment">// 最后一种情况，调用成功函数传入参数</span>
    <span class="token function">_resolve</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 最后把promise返回出去</span>
  <span class="token keyword">return</span> p<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="实现静态reject方法"><a href="#实现静态reject方法" class="header-anchor">#</a> 实现静态reject方法</h2> <p>官方描述：返回一个状态为已拒绝的 <code>Promise</code> 对象，并将给定的失败信息传递给对应的处理函数。</p> <p>无论你传什么参数进来，我给你返回一个 rejected 的对象</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 返回一个失败的promise即可</span>
<span class="token keyword">static</span> <span class="token function">reject</span><span class="token punctuation">(</span><span class="token parameter">reason</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">myPromise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token function">reject</span><span class="token punctuation">(</span>reason<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><!----> <span class="next"><a href="/docs/Native/PromiseInterView/">
          手撕Promise面试题
        </a>
        →
      </span></p></div> </main></div><div class="global-ui"><canvas id="vuepress-canvas-cursor"></canvas></div></div>
    <script src="/docs/assets/js/app.055589eb.js" defer></script><script src="/docs/assets/js/2.a4ce278c.js" defer></script><script src="/docs/assets/js/12.261b571c.js" defer></script>
  </body>
</html>
