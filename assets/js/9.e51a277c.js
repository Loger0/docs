(window.webpackJsonp=window.webpackJsonp||[]).push([[9],{283:function(t,s,a){"use strict";a.r(s);var v=a(10),_=Object(v.a)({},(function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"浏览器是什么时候开始渲染的"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#浏览器是什么时候开始渲染的"}},[t._v("#")]),t._v(" 浏览器是什么时候开始渲染的？")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a532b71fda054fa7a603c8c3d9fab4dd~tplv-k3u1fbpfcp-watermark.image?",alt:"渲染时间点.png"}})]),t._v(" "),a("ol",[a("li",[t._v("浏览器通过网络请求得到html文件")]),t._v(" "),a("li",[t._v("生成一个渲染任务，传递到消息队列中")]),t._v(" "),a("li",[t._v("渲染主线程通过事件循环拿到渲染任务开始渲染")])]),t._v(" "),a("h1",{attrs:{id:"渲染流程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#渲染流程"}},[t._v("#")]),t._v(" 渲染流程")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/35b78b0fc98b4389bb8525d7109593b3~tplv-k3u1fbpfcp-watermark.image?",alt:"渲染流程图.png"}})]),t._v(" "),a("ul",[a("li",[t._v("HTML 解析")]),t._v(" "),a("li",[t._v("样式计算")]),t._v(" "),a("li",[t._v("布局")]),t._v(" "),a("li",[t._v("分层")]),t._v(" "),a("li",[t._v("绘制")]),t._v(" "),a("li",[t._v("分块")]),t._v(" "),a("li",[t._v("光栅化")]),t._v(" "),a("li",[t._v("画")])]),t._v(" "),a("p",[a("strong",[t._v("每一个流程都有输入和输出，上一个流程的输出就是下一个流程的输入")])]),t._v(" "),a("h2",{attrs:{id:"第一步-解析html"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#第一步-解析html"}},[t._v("#")]),t._v(" 第一步 解析HTML")]),t._v(" "),a("ol",[a("li",[t._v("解析HTML遇到css解析css，遇到js解析js，但是浏览器会开一个预解析线程负责下载和解析css，js，率先下载外部的css和js")]),t._v(" "),a("li",[t._v("如果主线程遇到link标签会继续解析html，当css下载解释完成再交给主线程，是不会暂停等待的，所以css是不会阻塞html解析")]),t._v(" "),a("li",[t._v("如果主线程遇到script标签，会暂停等待html下载和执行同步代码完成才会继续解析html，因为js中可能会修改了dom元素，必须等待js执行完成，这就是为什么js会阻塞html解析的原因")]),t._v(" "),a("li",[t._v("解析html首先会创建一个document对象，我们所有的DOM对象都是添加到document对象中")]),t._v(" "),a("li",[t._v("把我们在html写的标签变成对象格式，因为对象可以方便我们在js中操作DOM")]),t._v(" "),a("li",[t._v("解析css也会创建一个StyleSheetList对象, 对象中有选择器名称和我们添加的css属性")]),t._v(" "),a("li",[t._v("最终把 html 和 css 解析成两个对象")])]),t._v(" "),a("p",[a("strong",[t._v("当这一步完成就可以得到DOM树和CSSOM树")])]),t._v(" "),a("h2",{attrs:{id:"第二步-样式计算"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#第二步-样式计算"}},[t._v("#")]),t._v(" 第二步 样式计算")]),t._v(" "),a("p",[t._v("我们经常会使用一些不确定的单位，这一步就是把这些预设值变成绝对值, 比如")]),t._v(" "),a("ul",[a("li",[t._v("em (相对父元素）")]),t._v(" "),a("li",[t._v("rem （相对根元素）")]),t._v(" "),a("li",[t._v("百分比")]),t._v(" "),a("li",[t._v(". . . . . .")])]),t._v(" "),a("ol",[a("li",[t._v("主线程遍历得到DOM树， 依次为每个节点计算出样式信息， 这一步叫做 "),a("strong",[t._v("Computer Style")])]),t._v(" "),a("li",[t._v("把我们的预设值变成绝对值， 比如 background-color: white, 变成 background-color: rgb(255,255,255), 相对单位变成绝对单位， em 变成 px")])]),t._v(" "),a("p",[a("strong",[t._v("这一步我们可以得到带有样式的DOM树")])]),t._v(" "),a("h2",{attrs:{id:"第三步-布局"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#第三步-布局"}},[t._v("#")]),t._v(" 第三步 布局")]),t._v(" "),a("ol",[a("li",[t._v("依次遍历，通过每个dom的节点的几何信息，比如宽高，相对包含块位置，计算出元素所在的位置")]),t._v(" "),a("li",[t._v("但是往往DOM树和布局树并不是一一对应的")])]),t._v(" "),a("p",[a("img",{attrs:{src:"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/aafdbbc8275a4ffa9e07b2ab92cfd6ac~tplv-k3u1fbpfcp-watermark.image?",alt:"布局树.png"}})]),t._v(" "),a("ul",[a("li",[t._v("当元素使用了 display: none 属性时， 在dom树中是有节点的，但是他并没有几何信息，所以没有必要添加到布局树当中")]),t._v(" "),a("li",[t._v("当使用了伪元素时，在dom树中是没有伪元素的节点信息的，但是有几何信息，是需要渲染到页面上的，所以要添加到布局树当中")])]),t._v(" "),a("p",[a("strong",[t._v("完成这一步可以得到布局树")])]),t._v(" "),a("h2",{attrs:{id:"第四步-分层"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#第四步-分层"}},[t._v("#")]),t._v(" 第四步 分层")]),t._v(" "),a("p",[t._v("浏览器会有一套复杂的策略对页面进行分层，分层可以提高浏览器的渲染效率，不会因为一个地方的变动而刷新整个页面，只是重新渲染一部分")]),t._v(" "),a("ul",[a("li",[t._v("我们在写css属性的时候有可能会影响到浏览器的分层结果，比如 z-index、滚动条、transform、opacity,也可以使用will-change更大程度影响分层结果")])]),t._v(" "),a("p",[a("img",{attrs:{src:"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4485265dd50e43af9b99edcfb3bef7df~tplv-k3u1fbpfcp-watermark.image?",alt:"分层.png"}})]),t._v(" "),a("ul",[a("li",[t._v("可以通过f12控制台中的Layers面板查看你的网页分层")])]),t._v(" "),a("h2",{attrs:{id:"第五步-生成绘制指令"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#第五步-生成绘制指令"}},[t._v("#")]),t._v(" 第五步 生成绘制指令")]),t._v(" "),a("ol",[a("li",[t._v("这里会为每一个图层生成出如何绘制的指令")])]),t._v(" "),a("p",[a("strong",[t._v("到这一步渲染主线程的工作就完成了，剩下交给合成线程完成")])]),t._v(" "),a("h2",{attrs:{id:"第六步-分块"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#第六步-分块"}},[t._v("#")]),t._v(" 第六步 分块")]),t._v(" "),a("ol",[a("li",[t._v("分块会将每一个图层切分成更小的区域，分块的工作是交给多线程完成的，他会通过线程池调取线程完成分块")])]),t._v(" "),a("h2",{attrs:{id:"第七步-光栅化"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#第七步-光栅化"}},[t._v("#")]),t._v(" 第七步 光栅化")]),t._v(" "),a("ol",[a("li",[t._v("光栅化就是把每一小块区域变成位图，位图就是由多个像素点组成，这里已经生成了颜色信息了")]),t._v(" "),a("li",[t._v("并且光栅化会优先处理靠近用户窗口的区域")])]),t._v(" "),a("h2",{attrs:{id:"第八步-画"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#第八步-画"}},[t._v("#")]),t._v(" 第八步 画")]),t._v(" "),a("ol",[a("li",[t._v("合成线程拿到每一个图层，和位图之后，生成quad信息")]),t._v(" "),a("li",[t._v("quad信息会指示出内容应该在什么位置，还有考虑是否有缩放，变形")]),t._v(" "),a("li",[t._v("transform就是在合成线程中完成的，与主线程无关，这就是transform效率高的原因")]),t._v(" "),a("li",[t._v("最后把quad信息交给GPU就可以把页面绘制出来了")])]),t._v(" "),a("h1",{attrs:{id:"什么是-reflow-重排"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#什么是-reflow-重排"}},[t._v("#")]),t._v(" 什么是 reflow （重排）")]),t._v(" "),a("ul",[a("li",[t._v("reflow的本质就是布局被修改了，需要重新计算布局树")]),t._v(" "),a("li",[t._v("浏览器为了提升效率，把多次修改导致布局树重复计算的操作，合并成一次操作")]),t._v(" "),a("li",[t._v("这也导致了我们有时候获取dom可能得到的不是想要的数据")]),t._v(" "),a("li",[t._v("浏览器也是有解决办法的，当 JS 获取布局属性时立即触发reflow那么就可以的到我们想要的数据了")])]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 举一个我遇到过的例子 在我做轮播图的时候，显示到最后一张图片时下一张应该立即跳到第一张")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 这个时候就要把轮播图滚动的过渡取消掉，但是后续还是需要这个过渡的")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 先把过渡取消")]),t._v("\n大盒子"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("style"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("transition "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'none'")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 这里我们改变轮播图的位置")]),t._v("\n图片"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("style"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("translate "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'0px'")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 读取布局属性导致 reflow")]),t._v("\n图片"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("clientWidth\n\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 再添加过渡")]),t._v("\n大盒子"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("style"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("transition "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'all .5s'")]),t._v("\n")])])]),a("p",[a("strong",[t._v("这个例子的意思就是你每一次执行的js代码对布局树的多次更改只会执行最终更改的结果，这个案例取消transition后面又添加了transition属性,这两部被合并了所以最终取消过渡失败，如果需要把两步分开在中间加一个读取布局属性就可以了")])]),t._v(" "),a("h1",{attrs:{id:"什么是-repaint-重绘"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#什么是-repaint-重绘"}},[t._v("#")]),t._v(" 什么是 repaint （重绘）")]),t._v(" "),a("ul",[a("li",[t._v("repaint的本质就是根据分层信息重新生成绘制指令")]),t._v(" "),a("li",[t._v("当我们修改了可见样式，比如 background color属性都会引起 repaint")]),t._v(" "),a("li",[t._v("由于元素的布局信息也属于可见样式，所以 reflow 一定会引起 repaint。")])])])}),[],!1,null,null,null);s.default=_.exports}}]);