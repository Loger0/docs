(window.webpackJsonp=window.webpackJsonp||[]).push([[11],{286:function(e,t,s){"use strict";s.r(t);var a=s(10),v=Object(a.a)({},(function(){var e=this,t=e.$createElement,s=e._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[s("p",[e._v("这篇文章根据A+规范和Promise官网描述实现的Promise，看完对Promise的理解增加90%")]),e._v(" "),s("p",[s("a",{attrs:{href:"https://juejin.cn/post/7232459954582126648",target:"_blank",rel:"noopener noreferrer"}},[e._v("手写原生Promise"),s("OutboundLink")],1)]),e._v(" "),s("h1",{attrs:{id:"promise的特性无非就这几种"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#promise的特性无非就这几种"}},[e._v("#")]),e._v(" Promise的特性无非就这几种")]),e._v(" "),s("ol",[s("li",[s("code",[e._v("Promise")]),e._v("的状态是不可逆的")]),e._v(" "),s("li",[s("code",[e._v("Promise")]),e._v("通过调用"),s("code",[e._v("resolve")]),e._v("和"),s("code",[e._v("reject")]),e._v("方法修改当前"),s("code",[e._v("Promise")]),e._v("的状态")]),e._v(" "),s("li",[s("code",[e._v("then")]),e._v("方法是异步执行的，是"),s("code",[e._v("微任务")]),e._v(",通过传入回调函数得到成功或失败后的结果")]),e._v(" "),s("li",[s("code",[e._v("then")]),e._v("方法不传入回调函数会有穿透效果，结果会传递到下一个"),s("code",[e._v("then")]),e._v("方法")]),e._v(" "),s("li",[s("code",[e._v("then")]),e._v("方法的返回值是立即成功的"),s("code",[e._v("Promise")]),e._v("对象，除非"),s("code",[e._v("then")]),e._v("方法内的回调函数发生报错")]),e._v(" "),s("li",[s("code",[e._v("then")]),e._v("方法是可以链式调用的，每个"),s("code",[e._v("then")]),e._v("得到的结果就是上一个"),s("code",[e._v("then")]),e._v("方法的返回值")]),e._v(" "),s("li",[s("code",[e._v("catch")]),e._v("方法在"),s("code",[e._v("Promise")]),e._v("状态为失败时执行，传入回调函数得到失败的结果")]),e._v(" "),s("li",[s("code",[e._v("catch")]),e._v("方法返回值是立即成功的"),s("code",[e._v("Promise")]),e._v("对象，除非"),s("code",[e._v("catch")]),e._v("方法内的回调函数发生报错")]),e._v(" "),s("li",[s("code",[e._v("finally")]),e._v("方法无论当前"),s("code",[e._v("Promise")]),e._v("状态成功还是失败都会执行，并且返回值为与当前"),s("code",[e._v("Promise")]),e._v("状态一致的"),s("code",[e._v("Promise")]),e._v("对象")]),e._v(" "),s("li",[s("code",[e._v("Promise.all()")]),e._v("方法将多个多个Promise实例，包装成一个新的"),s("code",[e._v("Promise")]),e._v("实例，该方法接受一个由"),s("code",[e._v("Promise")]),e._v("对象组成的数组作为参数("),s("code",[e._v("Promise.all()")]),e._v("方法的参数可以不是数组，但必须具有"),s("code",[e._v("Iterator")]),e._v("接口，且返回的每个成员都是"),s("code",[e._v("Promise")]),e._v("实例)，注意参数中只要有一个实例触发"),s("code",[e._v("catch")]),e._v("方法，都会触发"),s("code",[e._v("Promise.all()")]),e._v("方法返回的新的实例的"),s("code",[e._v("catch")]),e._v("方法，如果参数中的某个实例本身调用了"),s("code",[e._v("catch")]),e._v("方法，将不会触发"),s("code",[e._v("Promise.all()")]),e._v("方法返回的新实例的"),s("code",[e._v("catch")]),e._v("方法")]),e._v(" "),s("li",[s("code",[e._v("Promise.race()")]),e._v("方法的参数与"),s("code",[e._v("Promise.all")]),e._v("方法一样，参数中的实例只要有一个率先改变状态就会将该实例的状态传给"),s("code",[e._v("Promise.race()")]),e._v("方法，并将返回值作为"),s("code",[e._v("Promise.race()")]),e._v("方法产生的Promise实例的返回值")]),e._v(" "),s("li",[s("code",[e._v("Promise.resolve()")]),e._v("方法返回一个立即成功的"),s("code",[e._v("Promise")]),e._v("对象，并且传入的参数分3种情况："),s("code",[e._v("Promise自己的实例对象")]),e._v(" "),s("code",[e._v("满足A+规范的实例对象")]),e._v(" "),s("code",[e._v("传入值")]),e._v(" 三种情况的结果都不一样")]),e._v(" "),s("li",[s("code",[e._v("Promise.reject()")]),e._v("方法相对简单，返回值是立即失败的"),s("code",[e._v("Promise")]),e._v("对象，传入的参数是什么返回的"),s("code",[e._v("Promise")]),e._v("对象的值就是什么")])]),e._v(" "),s("h2",{attrs:{id:"状态不可逆"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#状态不可逆"}},[e._v("#")]),e._v(" 状态不可逆")]),e._v(" "),s("p",[e._v("在我们调用"),s("code",[e._v("resolve")]),e._v("方法或者"),s("code",[e._v("reject")]),e._v("方法时，只有当"),s("code",[e._v("Promise")]),e._v("的状态为"),s("code",[e._v("pending")]),e._v("时才可以修改为成功或者失败，先调用了"),s("code",[e._v("resolve")]),e._v("后调用"),s("code",[e._v("reject")]),e._v("，那么"),s("code",[e._v("reject")]),e._v("方法是没有效果的，比如：")]),e._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("new")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("Promise")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),s("span",{pre:!0,attrs:{class:"token parameter"}},[e._v("resolve"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v("reject")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=>")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n    "),s("span",{pre:!0,attrs:{class:"token function"}},[e._v("resolve")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[e._v("'成功'")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v("\n    "),s("span",{pre:!0,attrs:{class:"token function"}},[e._v("reject")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[e._v("'失败'")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v("\n")])])]),s("p",[e._v("这段代码最后的结果返回的是状态为"),s("code",[e._v("fulfilled")]),e._v("值为"),s("code",[e._v("成功")]),e._v("的"),s("code",[e._v("Promise")]),e._v("对象，"),s("code",[e._v("reject")]),e._v("方法执行了但是内部不会做任何行为")]),e._v(" "),s("h2",{attrs:{id:"异步调用resolve和reject方法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#异步调用resolve和reject方法"}},[e._v("#")]),e._v(" 异步调用resolve和reject方法")]),e._v(" "),s("p",[e._v("我们使用"),s("code",[e._v("Promise")]),e._v("更多情况是发送"),s("code",[e._v("AJAX")]),e._v("请求，"),s("code",[e._v("AJAX")]),e._v("是一个异步任务，所以我们在发送请求成功后调用"),s("code",[e._v("resolve")]),e._v("方法时为什么会等待异步任务完成后，还能获取到数据呢？ 这里使用定时器模拟请求，比如：")]),e._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("new")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("Promise")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),s("span",{pre:!0,attrs:{class:"token parameter"}},[e._v("resolve"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v("reject")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=>")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n    "),s("span",{pre:!0,attrs:{class:"token function"}},[e._v("setTimeout")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=>")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n      "),s("span",{pre:!0,attrs:{class:"token function"}},[e._v("resolve")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[e._v("'成功'")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v("\n")])])]),s("p",[e._v("因为我们传入的函数是同步执行的，所以修改不到状态，那么"),s("code",[e._v("Promise")]),e._v("内部通过把回调函数中所有的参数保存到对象中推到一个队列里面，当异步任务完成时修改了状态，就从队列中把所需的参数拿出来执行")]),e._v(" "),s("h2",{attrs:{id:"then方法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#then方法"}},[e._v("#")]),e._v(" then方法")]),e._v(" "),s("p",[s("code",[e._v("then")]),e._v("方法最关键的地方就在于他返回的是一个新的"),s("code",[e._v("Promise")]),e._v("对象，才足以实现这么多功能")]),e._v(" "),s("h3",{attrs:{id:"then内的回调函数是微任务"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#then内的回调函数是微任务"}},[e._v("#")]),e._v(" then内的回调函数是微任务")]),e._v(" "),s("p",[s("code",[e._v("then")]),e._v("方法中是异步执行的，有3种方法，首先判断你所处的是什么环境，使用不同的方法")]),e._v(" "),s("ol",[s("li",[e._v("首先判断有没有"),s("code",[e._v("process")]),e._v("对象，如果有则调用"),s("code",[e._v("precess.nextTick")]),e._v("方法实现微任务")]),e._v(" "),s("li",[e._v("判断有没有"),s("code",[e._v("MutationObserver")]),e._v("这个构造函数，如果有就使用"),s("code",[e._v("MutationObserver")]),e._v("实现微任务")]),e._v(" "),s("li",[e._v("都没有那只能使用"),s("code",[e._v("setTimeout")]),e._v("来实现异步，"),s("code",[e._v("setTimeout")]),e._v("内的回调会添加到延时队列，执行优先级会低于微任务")])]),e._v(" "),s("h3",{attrs:{id:"then方法的穿透效果"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#then方法的穿透效果"}},[e._v("#")]),e._v(" then方法的穿透效果")]),e._v(" "),s("p",[e._v("执行"),s("code",[e._v("then")]),e._v("时会去判断传入的回调函数是否为"),s("code",[e._v("function")]),e._v("类型，如果不为"),s("code",[e._v("function")]),e._v("那么会返回一个新的"),s("code",[e._v("Promise")]),e._v("对象，调用"),s("code",[e._v("resolve")]),e._v("方法把当前回调的结果传进去，那么下一个"),s("code",[e._v("then")]),e._v("方法就可以接收到上一个"),s("code",[e._v("then")]),e._v("的结果了")]),e._v(" "),s("h3",{attrs:{id:"链式调用"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#链式调用"}},[e._v("#")]),e._v(" 链式调用")]),e._v(" "),s("p",[s("code",[e._v("then")]),e._v("方法返回的是一个"),s("code",[e._v("Promise")]),e._v("对象，那么我们就可以调用他的原型方法了，返回"),s("code",[e._v("Promise")]),e._v("对象是链式调用的关键")]),e._v(" "),s("h2",{attrs:{id:"resolve静态方法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#resolve静态方法"}},[e._v("#")]),e._v(" resolve静态方法")]),e._v(" "),s("p",[e._v("我们传入的参数分三种情况")]),e._v(" "),s("ol",[s("li",[e._v("由"),s("code",[e._v("Promise")]),e._v("实例化的对象")])]),e._v(" "),s("p",[e._v("返回值为"),s("code",[e._v("Promise")]),e._v("对象，调用"),s("code",[e._v("resolve")]),e._v("方法，把传入这个对象，作为参数传入，调用"),s("code",[e._v("then")]),e._v("方法时得到的就是传入的"),s("code",[e._v("Promise")]),e._v("对象，举个例子：")]),e._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("const")]),e._v(" p "),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("new")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("Promise")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),s("span",{pre:!0,attrs:{class:"token parameter"}},[e._v("resolve"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v("reject")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=>")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n    "),s("span",{pre:!0,attrs:{class:"token function"}},[e._v("resolve")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[e._v("'成功'")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v("\n\nconsole"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[e._v("log")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("Promise"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[e._v("resolve")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("p"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("===")]),e._v(" p"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("// true")]),e._v("\n")])])]),s("ol",{attrs:{start:"2"}},[s("li",[e._v("传入一个满足A+规范的对象")])]),e._v(" "),s("p",[e._v("不管你是函数，构造函数，还是对象，只要你满足了"),s("code",[e._v("then")]),e._v("方法就是满足了A+规范，"),s("code",[e._v("Promise")]),e._v("内容判断你符合了A+规范时，会调用你自身的"),s("code",[e._v("then")]),e._v("方法，返回的结果取决于"),s("code",[e._v("then")]),e._v("方法")]),e._v(" "),s("ol",{attrs:{start:"3"}},[s("li",[e._v("传入普通值")])]),e._v(" "),s("p",[e._v("返回的就是一个成功状态的"),s("code",[e._v("Promise")]),e._v("，结果就为传入的参数")]),e._v(" "),s("h2",{attrs:{id:"await-async-跟-promise-的区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#await-async-跟-promise-的区别"}},[e._v("#")]),e._v(" await async 跟 Promise 的区别")]),e._v(" "),s("ol",[s("li",[e._v("都是用来处理异步代码请求的")]),e._v(" "),s("li",[e._v("Promise是es6出的，async await是es7出的")]),e._v(" "),s("li",[e._v("async await是基于Promise实现的，都是非阻塞性的")]),e._v(" "),s("li",[e._v("Promise是通过then()和catch()处理结果和捕获异常，可以链式调用，还是会出现回调地狱的情况")]),e._v(" "),s("li",[e._v("async await是通过try catch捕获异常")]),e._v(" "),s("li",[e._v("最大的区别就是async await代码看起来跟同步一样，当遇到await就会立即返回结果")])])])}),[],!1,null,null,null);t.default=v.exports}}]);